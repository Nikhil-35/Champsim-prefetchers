/*****************************************************
For the Third Data Prefetching Championship - DPC3

Paper ID: #4
Instruction Pointer Classifying Prefetcher - IPCP

Authors: 
Samuel Pakalapati - pakalapatisamuel@gmail.com
Biswabandan Panda - biswap@cse.iitk.ac.in
******************************************************/

#include "cache.h"

#define NUM_IP_TABLE_L2_ENTRIES 1024
#define NUM_IP_INDEX_BITS 10
#define NUM_IP_TAG_BITS 6
#define S_TYPE 1                                            // global stream (GS)
#define CS_TYPE 2                                           // constant stride (CS)
#define CPLX_TYPE 3                                         // complex stride (CPLX)
#define NL_TYPE 4                                           // next line (NL)

#define NUM_GHB_ENTRIES 16
// #define SIG_DEBUG_PRINT_L2
#ifdef SIG_DEBUG_PRINT_L2
#define SIG_DP(x) x
#else
#define SIG_DP(x)
#endif

class IP_TRACKER {
  public:
    uint64_t ip_tag;
    uint16_t ip_valid;
    uint32_t pref_type;                                     // prefetch class type
    int stride;                                             // last stride sent by metadata
    uint16_t str_dir;                                       // stream direction
    uint16_t str_valid;                                     // stream valid
    uint16_t str_strength;                                  // stream strength
    IP_TRACKER () {
        ip_tag = 0;
        ip_valid = 0;
        pref_type = 0;
        stride = 0;
        str_dir = 0;
        str_valid = 0;
        str_strength = 0;
    };
};

uint32_t spec_nl_l2[NUM_CPUS] = {0};
IP_TRACKER trackers[NUM_CPUS][NUM_IP_TABLE_L2_ENTRIES];

int decode_stride(uint32_t metadata){
    int stride=0;
    if(metadata & 0b1000000)
        stride = -1*(metadata & 0b111111);
    else
        stride = metadata & 0b111111;

    return stride;
}

void CACHE::l2c_prefetcher_initialize() 
{

}
uint64_t ghb_l2[NUM_CPUS][NUM_GHB_ENTRIES];
void check_for_stream_l2(int index, uint64_t cl_addr, uint8_t cpu){
int pos_count=0, neg_count=0, count=0;
uint64_t check_addr = cl_addr;

// check for +ve stream
    for(int i=0; i<NUM_GHB_ENTRIES; i++){
        check_addr--;
        for(int j=0; j<NUM_GHB_ENTRIES; j++)
            if(check_addr == ghb_l2[cpu][j]){
                pos_count++;
                break;
            }
    }

check_addr = cl_addr;
// check for -ve stream
    for(int i=0; i<NUM_GHB_ENTRIES; i++){
        check_addr++;
        for(int j=0; j<NUM_GHB_ENTRIES; j++)
            if(check_addr == ghb_l2[cpu][j]){
                neg_count++;
                break;
            }
    }

    if(pos_count > neg_count){                                // stream direction is +ve
        trackers[cpu][index].str_dir = 1;
        count = pos_count;
    }
    else{                                                     // stream direction is -ve
        trackers[cpu][index].str_dir = 0;
        count = neg_count;
    }

if(count > NUM_GHB_ENTRIES/2){                                // stream is detected
    trackers[cpu][index].str_valid = 1;
    if(count >= (NUM_GHB_ENTRIES*3)/4)                        // stream is classified as strong if more than 3/4th entries belong to stream
        trackers[cpu][index].str_strength = 1;
}
else{
    if(trackers[cpu][index].str_strength == 0)             // if identified as weak stream, we need to reset
        trackers[cpu][index].str_valid = 0;
}

}

uint32_t CACHE::l2c_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint32_t metadata_in)
{

    uint64_t cl_addr = addr >> LOG2_BLOCK_SIZE;
    int prefetch_degree = 0;
    int64_t stride = decode_stride(metadata_in);
    uint32_t pref_type = metadata_in & 0xF00;
    uint16_t ip_tag = (ip >> NUM_IP_INDEX_BITS) & ((1 << NUM_IP_TAG_BITS)-1);

if(NUM_CPUS == 1){
   if (MSHR.occupancy < (1*MSHR.SIZE)/2)
    prefetch_degree = 4;
   else 
    prefetch_degree = 3;  
} else {                                    // tightening the degree for multi-core
    prefetch_degree = 2;
}

// calculate the index bit
int index = ip & ((1 << NUM_IP_INDEX_BITS)-1);
    if(trackers[cpu][index].ip_tag != ip_tag){              // new/conflict IP
        if(trackers[cpu][index].ip_valid == 0){             // if valid bit is zero, update with latest IP info
        trackers[cpu][index].ip_tag = ip_tag;
        trackers[cpu][index].pref_type = pref_type;
        trackers[cpu][index].stride = stride;
    } else {
        trackers[cpu][index].ip_valid = 0;                  // otherwise, reset valid bit and leave the previous IP as it is
    }

        // issue a next line prefetch upon encountering new IP
        uint64_t pf_address = ((addr>>LOG2_BLOCK_SIZE)+1) << LOG2_BLOCK_SIZE;
        prefetch_line(ip, addr, pf_address, FILL_L2, 0);
        SIG_DP(cout << "1, ");
        return metadata_in;
    }
    else {                                                  // if same IP encountered, set valid bit
        trackers[cpu][index].ip_valid = 1;
    }

// update the IP table upon receiving metadata from prefetch
    if( type == PREFETCH ){
    trackers[cpu][index].pref_type = pref_type;
    trackers[cpu][index].stride = stride;
    spec_nl_l2[cpu] = metadata_in & 0x1000;
    }
SIG_DP(
cout << ip << ", " << cache_hit << ", " << cl_addr << ", ";
cout << ", " << stride << "; ";
);


// we are prefetching only for GS, CS and NL classes
    if(trackers[cpu][index].stride != 0){ 
        if(trackers[cpu][index].pref_type == 0x100 || trackers[cpu][index].pref_type == 0x200){      // GS or CS class   
          if(trackers[cpu][index].pref_type == 0x100)
           if(NUM_CPUS == 1)
              prefetch_degree = 4;    
            for (int i=0; i<prefetch_degree; i++) {
                uint64_t pf_address = (cl_addr + (trackers[cpu][index].stride*(i+1))) << LOG2_BLOCK_SIZE;
                
                // Check if prefetch address is in same 4 KB page
                if ((pf_address >> LOG2_PAGE_SIZE) != (addr >> LOG2_PAGE_SIZE))
                    break;
                
                prefetch_line(ip, addr, pf_address, FILL_L2,0);
                SIG_DP(cout << trackers[cpu][index].stride << ", ");
            }
        }
        else if(trackers[cpu][index].pref_type == 0x400 && spec_nl_l2[cpu] > 0){
        uint64_t pf_address = ((addr>>LOG2_BLOCK_SIZE)+1) << LOG2_BLOCK_SIZE;   
        prefetch_line(ip, addr, pf_address, FILL_L2, 0);
        SIG_DP(cout << "1;");
        }
    }
    else {
   //cout << "here" << endl; 
    check_for_stream_l2(index, cl_addr, cpu);           
        if(trackers[cpu][index].str_valid == 1){                         // stream IP
        // for stream, prefetch with twice the usual degree
            prefetch_degree = prefetch_degree*2;
	cout << "me" << endl;
        for (int i=0; i<prefetch_degree; i++) {
            uint64_t pf_address = 0;

            if(trackers[cpu][index].str_dir == 1){                   // +ve stream
                pf_address = (cl_addr + i + 1) << LOG2_BLOCK_SIZE;
            }
            else{                                                       // -ve stream
                pf_address = (cl_addr - i - 1) << LOG2_BLOCK_SIZE;
               // stride is -1
            }

            // Check if prefetch address is in same 4 KB page
            if ((pf_address >> LOG2_PAGE_SIZE) != (addr >> LOG2_PAGE_SIZE)){
                break;
            }

            prefetch_line(ip, addr, pf_address, FILL_L2, 0);
            SIG_DP(cout << "1, ");
            }

    }
    
    }
   

SIG_DP(cout << endl);


return metadata_in;
}

uint32_t CACHE::l2c_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{
return metadata_in;
}

void CACHE::l2c_prefetcher_final_stats()
{

}

